#!/bin/sh
# Pull and push on a Git repository but only if it has a valid remote and state is clean.
# This does a job similar to git sync but is more suitable for automated envs.

# usage: git-sync <path-to-parent-dir> (optional)

# Utils
# text formatting 
_reset="\e[0;0m"
_yellow="\e[1;33m"
_blue="\e[1;34m"
_strong="\e[1;39m"

# terminate when a command returns a non-zero exit code 
# note: '||:' at the end of a pipe mask a non-zero exit
set -e

# Main
# change dir to inputted path if valid
if [ -d "$1" ]; then
  cd "$1" || exit
fi

# get repo name
path="$(pwd)"
repo="${path##/*/}"
_repo_root=$(git rev-parse --show-toplevel 2>/dev/null)

# Check before acting
_check() {
  # check if repo has remotes
  [ "$(git remote | wc -l)" = 0 ] && return 1

  # check if repo is in a dirty state
  # NOTE: it may be necessary to run git diff first to ensure the index is up to date
  git diff --quiet; git diff-index --quiet HEAD -- || return 1
  return 0

  # TODO: Improve dirty/valid repo detection.
}

# Pull changes
_pull() {
  if git rev-parse --is-shallow-repository >/dev/null; then
    git pull --ff-only --rebase
  else
    # NOTE: Fetching all is important to fetch upstream commits on forks.
    git pull --all --ff-only --rebase
  fi
}

# Push changes
_push() {
  # check if branch is main/master otherwise return 
  _branch=$(git symbolic-ref --short HEAD)
  ! [ "$_branch" = "main" ] && ! [ "$_branch" = "master" ] && return 1 

  # Check for unpushed commits
  [ "$(git rev-list HEAD@\{upstream\}..HEAD | wc -l)" = 0 ] && return 1

  # NOTE: Authentication is completely server-side and Git can't know if user
  # is allowed to push. A workaround to prevent pushes is to set 'pushurl' to
  # an invalid value.

  # don't push on gerrit repos.
  git remote | grep gerrit && return 1

  git push
}

printf "${_strong}Working on ${_yellow}%s${_reset}\n" "$repo"
_check && _pull && _push
printf "${_strong}Done on ${_blue}%s${_reset}\n\n" "$repo"
